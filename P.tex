\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{clrscode3e}


\usepackage{geometry}
\geometry{a4paper}
\lstset{tabsize=2}

\title{Дек}
\author{Санду Р.А.}

\begin{document}
\maketitle

Будем реализовывать дек на зацикленном динамическом массиве. Для этого, помимо нужно поддерживать 3 значения: размер динамического массива $n$, размер дека $s$, индекс начала дека $b$. Сам дек обозначим $D$, а элементы динамического массива $A_i$. Также будем поддерживать инварианты: $n$ является степенью двойки, $1 \leq n$, $\frac{n}{4}<s<n$. При нарушении инвариантов, будем либо увеличивть $n$ в $2$ раза, либо в $2$ раза уменьшать. Для простоты реализации, меньше единицы $n$ не будем делать никогда.

\hspace{1 mm}

Операция $\proc{Get}$:
\begin{codebox}
\Procname{$\proc{Get}(i)$}
\li	\Comment Значение возвращается по ссылке, т.е. с возможностью изменения
\li	\Return $A_{(b+i)\%n}$
\end{codebox}
\hspace{1 mm}

Операция $\proc{Restore-Invariants}$:
\begin{codebox}
\Procname{$\proc{Restore-Invariants}()$}
\li	\If $s \isequal n$
	\Then
\li		\Comment Выделение нового массива $B$ размера $2n$
\li		\Comment Перемещение элементов $\proc{Get}(0 \twodots s-1)$ в $B_{0..s-1}$
\li		$A \gets B$
\li		$b \gets 0$
\li		$n \gets 2n$
	\ElseIf $4s \leq n$ and $1 \leq \frac{n}{2}$
	\Then
\li		\Comment Выделение нового массива $B$ размера $\frac{n}{2}$
\li		\Comment Перемещение элементов $\proc{Get}(0 \twodots s-1)$ в $B_{0..s-1}$
\li		$A \gets B$
\li		$b \gets 0$
\li		$n \gets \frac{n}{2}$
	\End
\end{codebox}
\hspace{1 mm}

Операция $\proc{Push-Back}$:
\begin{codebox}
\Procname{$\proc{Push-Back}(v)$}
\li	$\proc{Get}(size) \gets v$
\li	$s \gets s+1$
\li	$\proc{Restore-Invariants}()$
\end{codebox}
\hspace{1 mm}

Операция $\proc{Push-Front}$:
\begin{codebox}
\Procname{$\proc{Push-Back}(v)$}
\li	\Comment Подразумевается "правильное" математическое определение взятия по модулю
\li	$b \gets (b-1)\%n$
\li	$\proc{Get}(0) \gets v$
\li	$s \gets s+1$
\li	$\proc{Restore-Invariants}()$
\end{codebox}
\hspace{1 mm}

Операция $\proc{Pop-Back}$:
\begin{codebox}
\Procname{$\proc{Pop-Back}()$}
\li	$s \gets s-1$
\li	$\proc{Restore-Invariants}()$
\end{codebox}
\hspace{1 mm}

Операция $\proc{Pop-Front}$:
\begin{codebox}
\Procname{$\proc{Pop-Back}()$}
\li	$b \gets b+1$
\li	$s \gets s-1$
\li	$\proc{Restore-Invariants}()$
\end{codebox}
\hspace{1 mm}


Проведём амортизационный анализ этих операций методом учётных стоимостей. 

Не сложно заметить, что операции $\proc{Push-Back}$ и $\proc{Push-Front}$, $\proc{Pop-Back}$ и $\proc{Pop-Front}$ имеют одинаковый с точки зрения асимптотики принцип работы, поэтому будем рассматривать операции $\proc{Push}$ и $\proc{Pop}$, которые работают за $O(1)$, если не нарушили инвариант, и за $O(s)$ иначе. Положим реальные стоимости обоих операций равными $1$. Также довольно целесообразно рассматривать индексацию этого индексированного массива так, как она указана в операции $\proc{Get}$. 

Операция $\proc{Push}$, не учитывая нарушения инвариантов. Положим её амортизированную стоимость равной $3$. При добавлении элемента будем класть 1 из монет на сам добавленный элемент, одну монету будем тратить на выполнение самой операции, а оставшуюся монету будем класть на любой из элементов, на котором лежит минимальной кол-во монет.

Операция $\proc{Pop}$, не учитывая нарушения инвариантов. Её амортизированная стоимость пусть будет равна $2$. Тогда при удалении элемента будем одну монету тратить на выполнение операции, а одну из них класть аналогично последней монете для $\proc{Push}$.

Оплаченность операции по востановлению инварианта будем доказывать по индукции. База — при создании стека всё оплачено. Переход. Пусть инвариант только что был востановлен. Тогда $s=2^k$. Из вышенаписанного следует, что до момента нарушения инвариантов все операции оплачены. 

Пусть мы совершили операцию $\proc{Pop}$ и нарушили инвариант. Тогда с момента востановления инварианта, после которого у нас могло быть суммарно 0 монет на всех элементах, прошло не меньше $2^{k-1}$ операций, а следовательно на каждом из $2^{k-1}$ оставшихся элементов лежит хотя бы по одной монете, которые мы и используем на перемещение этих элементов в новый массив. 

Пусть мы совершили операцию $\proc{Push}$ и нарушили инвариант. Тогда с момента востановления инварианта, прошло как минимум $2^{k}$ операций $\proc{Push}$, а значит на каждом из $2^{k+1}$ элементов лежит как минимум одна монета, а значит перемещение всех элементов оплачено.

Таким образом, шаг индукции завершён: после востановления инварианта суммарное кол-во монет не станет отрицательным и все операции оплачены. Получаем амортизированную сложность всех операций $O(1)$.

\hspace{1 mm}\linebreak

Проведём амортизационный анализ методом потенциалов.

Будем рассматривать последовательность операций и состояний $D_i$, где $c_i$ — стоимость операции из состояния $D_i$ в $D_{i+1}$, а $\hat{c}_i$ — её амортизированная стоимость. Возьмём следующую функцию потенциала
\[
	\Phi(D)=
		\begin{cases}
			2s-n & \left\lfloor\frac{1}{2}n\right\rfloor < s \\
			\left\lfloor\frac{1}{2}n\right\rfloor-s & s \leq \left\lfloor\frac{1}{2}n\right\rfloor
		\end{cases}
\]
Для неё по определению
\[
	\forall i. \Phi(D_0) = 0 < \Phi(D_i)
\]

а следовательно функция потенциала определена корректно.

Найдём амортизированную стоимость всех операций
\[
	\hat{c}_i= c_i + \Phi(D_{i+1}) - \Phi(D_i).
\]

Округление вниз в формулах опустим, т.к. оно играет роль только при $n=1$, а в этом тривиальном случае все операции точно занимают константное время. Для $\proc{Push}$:

1й случай — $s < \frac{1}{2}n$
\[
	\hat{c}_i= c_i + (\frac{1}{2}n-s-1) - (\frac{1}{2}n-s) = 0
\]
2й случай — $s = \frac{1}{2}n$
\begin{equation}
	\begin{split}
		\hat{c}_i & =  c_i + (2s+2-n) - (\frac{1}{2}n-s) \\ 
			& = c_i + 2 + 3s-\frac{3}{2}n \\
			& = c_i+2 +3\frac{n}{2}-\frac{3}{2}n \\
			& = c_i + 2 = 3
	\end{split}
\end{equation}
3й случай — $\frac{1}{2}n < s$
\[
	\hat{c}_i= c_i + (2s+2-n) - (2s-n) = 3
\]
4й случай — $s+1 = n$
\begin{equation}
	\begin{split}
		\hat{c}_i & = c_i + (\frac{1}{2}2n-(s+1)) - (2s-n) \\
			& = c_i + (n-n)-(2(n-1)-n) \\
			& = c_i - n + 2 = \\
			& = n - n + 2 = 2
	\end{split}
\end{equation}

Получаем константную стоимость во всех случаях, а следовательно амортизированную асимптотику $O(1)$.
Для $\proc{Pop}$:

1й случай — $s+1 = \frac{1}{4}n$
\begin{equation}
	\begin{split}
		\hat{c}_i & = c_i + (\frac{1}{4}n-(s+1)) - (\frac{1}{2}n-s) \\
			& = c_i + (\frac{1}{4}n-\frac{1}{4}n)-(\frac{1}{2}n-\frac{1}{4}n - 1) \\
			& = c_i - \frac{1}{4}n + 1 = \\
			& = \frac{1}{4}n - \frac{1}{4}n + 1 = 1
	\end{split}
\end{equation}
2й случай — $s \leq \frac{1}{2}n$
\[
	\hat{c}_i= c_i + (\frac{1}{2}n-s+1) - (\frac{1}{2}n-s) = 2
\]
3й случай — $s - 1 = \frac{1}{2}n$
\begin{equation}
	\begin{split}
		\hat{c}_i & =  c_i + (\frac{1}{2}n-s+1) - (2s-n) \\ 
			& = c_i - 1 - 3s + \frac{3}{2}n \\
			& = c_i - 1 + 3\frac{n}{2} + 3 -\frac{3}{2}n \\
			& = c_i + 2 = 3
	\end{split}
\end{equation}
4й случай — $\frac{1}{2}n < s - 1$
\[
	\hat{c}_i= c_i + (2s-2-n) - (2s-n) = -1
\]

Таким образом, получаем константную стоимость во всех случаях, а значит амортизированную асимптотику $O(1)$.




\end{document}